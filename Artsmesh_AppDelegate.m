////  Artsmesh_AppDelegate.m////  Version: 0.2.1//  Authors: WANG Hailei, JIA Chao//  Created by WANG Hailei on 7/19/10.//  Copyright 2010 Farefore. All rights reserved.//#import "Artsmesh_AppDelegate.h"//const NSString *serverBaseAddress=@"http://127.0.0.1:3000/";// Hard Code here for current user name and local IP address//const NSString *currentIPAddress=@"127.0.0.1";@implementation Artsmesh_AppDelegate@synthesize persistentStoreCoordinator;@synthesize managedObjectModel;@synthesize managedObjectContext;@synthesize window;@synthesize contactsTable;@synthesize contactsController;@synthesize currentHostIPAddress;@synthesize currentHostArtistName;@synthesize participatedArtistNames;@synthesize taskContainer;/*- (void) setHostIPAddressType:(NSString *)addressType {		if ( [addressType isEqualToString:@"IPv4"] == YES ) {		self.currentHostIPAddress = [[[NSHost currentHost] addresses] objectAtIndex:1];			} else {		self.currentHostIPAddress = [[[NSHost currentHost] addresses] objectAtIndex:0];			} }*/- (void) applicationDidFinishLaunching:(NSNotification *)aNotification {		// Insert code here to initialize your application 	taskContainer=[[JackTripTaskContainer alloc] init];	// Default set IP verson to 4.	[self setIPVersion4:self];		// TODO: Get the real currentHostArtistName;	self.currentHostArtistName = [NSMutableString stringWithFormat:@"Current Host Artist Name"];}- (IBAction) setIPVersion4:(id)sender {		self.currentHostIPAddress = [[[NSHost currentHost] addresses] objectAtIndex:1];		NSLog(@"currentHostIPAddress is : %@", self.currentHostIPAddress);}- (IBAction) setIPVersion6:(id)sender {	self.currentHostIPAddress = [[[NSHost currentHost] addresses] objectAtIndex:0];		NSLog(@"currentHostIPAddress is : %@", self.currentHostIPAddress);}- (IBAction) callTerminalCommands:(id)sender {	// Start jack server	//taskContainer.jackServerTask=[JackTripTaskHelper startJackServer];		// Launch server tasks	NSArray *serverChanelList=taskContainer.jackServerChanelList;	taskContainer.jackTripServerTaskList=[JackTripTaskHelper buildJackTaskList:serverChanelList];		NSArray *serverTaskList=taskContainer.jackTripServerTaskList;	[serverTaskList retain];	[JackTripTaskHelper launchTaskList:&serverTaskList];		// Launch client tasks	NSArray *clientChanelList=taskContainer.jackClientChanelList;	taskContainer.jackTripClientTaskList=[JackTripTaskHelper buildJackTaskList:clientChanelList];		NSArray *clientTaskList=taskContainer.jackTripClientTaskList;	[clientTaskList retain];	[JackTripTaskHelper launchTaskList:&clientTaskList];}- (IBAction) stopTerminalCommands:(id)sender {	// Terminate client tasks	NSArray *clientTaskList=taskContainer.jackTripClientTaskList;	[JackTripTaskHelper terminateTaskList:&clientTaskList];		// Terminate server tasks	NSArray *serverTaskList=taskContainer.jackTripServerTaskList;	[JackTripTaskHelper terminateTaskList:&serverTaskList];		// Stop jack server	//NSTask *jackServerTask=taskContainer.jackServerTask;	//[JackTripTaskHelper terminateTask:&jackServerTask];}- (IBAction) createRoom:(id)sender {		// Before creating new room, remove/destroy the might existing previous room.	NSString * getUrl = [NSString stringWithFormat:@"%@%@", CENTRAL_SERVER_ADDRESS, @"rooms/delete"];	[RESTfulRequestHelper sendGETRequest:getUrl];		// Preparing the parameters for creating new room.	for ( NSDictionary * anArtistInfo in [self.contactsController selectedObjects] ) {		[self.participatedArtistNames appendString:[NSString stringWithFormat:@"%@,",(NSString *)[anArtistInfo objectForKey:@"IMPersonScreenNameKey"]]];	}	[self.participatedArtistNames substringToIndex:([self.participatedArtistNames length]-2)]; // Omit the last comma.	NSLog(@"participatedArtistNames is : %@", self.participatedArtistNames);	// Compose XML data	NSString * postData = [NSString stringWithFormat:@"<?xml version='1.0' encoding='UTF-8' ?><room><Name>Room1</Name><Artists>%@</Artists></room>", self.participatedArtistNames];	NSString * postUrl  = [NSString stringWithFormat:@"%@%@", CENTRAL_SERVER_ADDRESS, @"rooms.xml"];	// Creat room through a RESTful post request.	NSString * responseString = [RESTfulRequestHelper sendPOSTRequestWithXmlText:postUrl xmlText:postData];		// For debugging.	NSLog(@"%@",responseString);}/* // Moved into createRoom:- (IBAction) removeRoom:(id)sender{	NSString *getUrl=[NSString stringWithFormat:@"%@%@", CENTRAL_SERVER_ADDRESS, @"rooms/delete"];	[RESTfulRequestHelper sendGETRequest:getUrl];}*/- (IBAction) readyCommand:(id)sender {		//	NSString *postData=[NSString stringWithFormat:@"<?xml version='1.0' encoding='UTF-8' ?><artist><Name>%@</Name><IP>%@</IP><RoomName>Room1</RoomName><Status>0</Status><Ports>4467,4468,4469</Ports></artist>", self.currentHostArtistName, [self.myIPAddress stringValue]];//	NSString *postUrl=[NSString stringWithFormat:@"%@%@", CENTRAL_SERVER_ADDRESS, @"artists.xml"];	NSString * postData = [NSString stringWithFormat:@"<?xml version='1.0' encoding='UTF-8' ?><artist><Name>%@</Name><IP>%@</IP><RoomName>Room1</RoomName><Status>0</Status><Ports>4467,4468,4469</Ports></artist>", self.currentHostArtistName, currentHostIPAddress];	NSString * postUrl  = [NSString stringWithFormat:@"%@%@", CENTRAL_SERVER_ADDRESS, @"artists.xml"];	NSString * responseString = [RESTfulRequestHelper sendPOSTRequestWithXmlText:postUrl xmlText:postData];	NSLog(@"%@",responseString);		// Change status to 1	NSString *getUrl=[NSString stringWithFormat:@"%@artists/%@.1.xml", CENTRAL_SERVER_ADDRESS, self.currentHostArtistName];	[RESTfulRequestHelper sendGETRequest:getUrl];		// Run loop to get expected response xml message	BOOL runLoopFlag=YES;	NSString *getRunLoopUrl=nil;	NSString *responseText=nil;		// Get server chanel list	do {				getRunLoopUrl=[NSString stringWithFormat:@"%@scripts/server/%@.xml", CENTRAL_SERVER_ADDRESS, self.currentHostArtistName];		NSLog(@"%@",getRunLoopUrl);		responseText=[RESTfulRequestHelper sendGETRequest:getRunLoopUrl];				if ([responseText isEqualToString:@"<message>waiting</message>"] || [responseText isEqualToString:@"<message>error</message>"]) {			runLoopFlag=YES;		}		else {			runLoopFlag=NO;		}				// Sleep for 0.5 seconds		[NSThread sleepForTimeInterval:0.5];	} while (runLoopFlag);		NSArray *serverChanelList=[JackTripChanelInfo getJackTripChanelListFromXml:responseText];	[serverChanelList retain];	taskContainer.jackServerChanelList=serverChanelList;		// Launch server tasks	taskContainer.jackTripServerTaskList=[JackTripTaskHelper buildJackTaskList:serverChanelList];	NSArray *serverTaskList=taskContainer.jackTripServerTaskList;	[serverTaskList retain];	[JackTripTaskHelper launchTaskList:&serverTaskList];		// Change status to 2	getUrl=[NSString stringWithFormat:@"%@artists/%@.2.xml", CENTRAL_SERVER_ADDRESS, self.currentHostArtistName];	[RESTfulRequestHelper sendGETRequest:getUrl];		// Get client chanel list	runLoopFlag=YES;	do {				getRunLoopUrl=[NSString stringWithFormat:@"%@scripts/client/%@.xml", CENTRAL_SERVER_ADDRESS, self.currentHostArtistName];		responseText=[RESTfulRequestHelper sendGETRequest:getRunLoopUrl];				if ([responseText isEqualToString:@"<message>waiting</message>"] || [responseText isEqualToString:@"<message>error</message>"]) {			runLoopFlag=YES;		}		else {			runLoopFlag=NO;		}				// Sleep for 0.5 seconds		[NSThread sleepForTimeInterval:0.5];	} while (runLoopFlag);	NSArray *clientChanelList=[JackTripChanelInfo getJackTripChanelListFromXml:responseText];	[clientChanelList retain];	taskContainer.jackClientChanelList=clientChanelList;		// Launch client tasks	taskContainer.jackTripClientTaskList=[JackTripTaskHelper buildJackTaskList:clientChanelList];	NSArray *clientTaskList=taskContainer.jackTripClientTaskList;	[clientTaskList retain];	[JackTripTaskHelper launchTaskList:&clientTaskList];		// Change status to 3	getUrl=[NSString stringWithFormat:@"%@artists/%@.3.xml", CENTRAL_SERVER_ADDRESS, self.currentHostArtistName];	[RESTfulRequestHelper sendGETRequest:getUrl];}- (IBAction) launchiChat:(id)sender {		[ChatTaskHelper launchiChat];}/** Returns the support directory for the application, used to store the Core Data store file.  This code uses a directory named "Artsmesh" for the content, either in the NSApplicationSupportDirectory location or (if the former cannot be found), the system's temporary directory. */- (NSString *) applicationSupportDirectory {		NSArray *paths = NSSearchPathForDirectoriesInDomains(NSApplicationSupportDirectory, NSUserDomainMask, YES);	NSString *basePath = ([paths count] > 0) ? [paths objectAtIndex:0] : NSTemporaryDirectory();	return [basePath stringByAppendingPathComponent:@"Artsmesh"];}			       #pragma mark -#pragma mark Application Framework Methods			       /** Creates, retains, and returns the managed object model for the application  by merging all of the models found in the application bundle. */- (NSManagedObjectModel *) managedObjectModel {		if (managedObjectModel) return managedObjectModel;		managedObjectModel = [[NSManagedObjectModel mergedModelFromBundles:nil] retain];    	return managedObjectModel;}/** Returns the persistent store coordinator for the application.  This  implementation will create and return a coordinator, having added the  store for the application to it.  (The directory for the store is created,  if necessary.) */- (NSPersistentStoreCoordinator *) persistentStoreCoordinator {		if (persistentStoreCoordinator) return persistentStoreCoordinator;		NSManagedObjectModel *mom = [self managedObjectModel];	if (!mom) {		NSAssert(NO, @"Managed object model is nil");		NSLog(@"%@:%s No model to generate a store from", [self class], _cmd);		return nil;	}		NSFileManager *fileManager = [NSFileManager defaultManager];	NSString *applicationSupportDirectory = [self applicationSupportDirectory];	NSError *error = nil;		if ( ![fileManager fileExistsAtPath:applicationSupportDirectory isDirectory:NULL] ) {		if (![fileManager createDirectoryAtPath:applicationSupportDirectory withIntermediateDirectories:NO attributes:nil error:&error]) {			NSAssert(NO, ([NSString stringWithFormat:@"Failed to create App Support directory %@ : %@", applicationSupportDirectory,error]));			NSLog(@"Error creating application support directory at %@ : %@",applicationSupportDirectory,error);			return nil;		}	}		NSURL *url = [NSURL fileURLWithPath: [applicationSupportDirectory stringByAppendingPathComponent: @"storedata"]];	persistentStoreCoordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel: mom];	if (![persistentStoreCoordinator addPersistentStoreWithType:NSXMLStoreType 						      configuration:nil 								URL:url 							    options:nil 							      error:&error]){		[[NSApplication sharedApplication] presentError:error];		[persistentStoreCoordinator release], persistentStoreCoordinator = nil;		return nil;	}    		return persistentStoreCoordinator;}/** Returns the managed object context for the application (which is already bound to the persistent store coordinator for the application.)  */- (NSManagedObjectContext *) managedObjectContext {		if (managedObjectContext) return managedObjectContext;		NSPersistentStoreCoordinator *coordinator = [self persistentStoreCoordinator];	if (!coordinator) {		NSMutableDictionary *dict = [NSMutableDictionary dictionary];		[dict setValue:@"Failed to initialize the store" forKey:NSLocalizedDescriptionKey];		[dict setValue:@"There was an error building up the data file." forKey:NSLocalizedFailureReasonErrorKey];		NSError *error = [NSError errorWithDomain:@"YOUR_ERROR_DOMAIN" code:9999 userInfo:dict];		[[NSApplication sharedApplication] presentError:error];		return nil;	}	managedObjectContext = [[NSManagedObjectContext alloc] init];	[managedObjectContext setPersistentStoreCoordinator: coordinator];		return managedObjectContext;}/** Returns the NSUndoManager for the application.  In this case, the manager returned is that of the managed object context for the application. */- (NSUndoManager *) windowWillReturnUndoManager:(NSWindow *)window {	return [[self managedObjectContext] undoManager];}/** Performs the save action for the application, which is to send the save: message to the application's managed object context.  Any encountered errors are presented to the user. */- (IBAction) saveAction:(id)sender {		NSError *error = nil;		if (![[self managedObjectContext] commitEditing]) {		NSLog(@"%@:%s unable to commit editing before saving", [self class], _cmd);	}		if (![[self managedObjectContext] save:&error]) {		[[NSApplication sharedApplication] presentError:error];	}}/** Implementation of the applicationShouldTerminate: method, used here to handle the saving of changes in the application managed object context before the application terminates. */- (NSApplicationTerminateReply) applicationShouldTerminate:(NSApplication *)sender {		if (!managedObjectContext) return NSTerminateNow;		if (![managedObjectContext commitEditing]) {		NSLog(@"%@:%s unable to commit editing to terminate", [self class], _cmd);		return NSTerminateCancel;	}		if (![managedObjectContext hasChanges]) return NSTerminateNow;		NSError *error = nil;	if (![managedObjectContext save:&error]) {				// This error handling simply presents error information in a panel with an 		// "Ok" button, which does not include any attempt at error recovery (meaning, 		// attempting to fix the error.)  As a result, this implementation will 		// present the information to the user and then follow up with a panel asking 		// if the user wishes to "Quit Anyway", without saving the changes.				// Typically, this process should be altered to include application-specific 		// recovery steps.                  		BOOL result = [sender presentError:error];		if (result) return NSTerminateCancel;				NSString *question = NSLocalizedString(@"Could not save changes while quitting.  Quit anyway?", @"Quit without saves error question message");		NSString *info = NSLocalizedString(@"Quitting now will lose any changes you have made since the last successful save", @"Quit without saves error question info");		NSString *quitButton = NSLocalizedString(@"Quit anyway", @"Quit anyway button title");		NSString *cancelButton = NSLocalizedString(@"Cancel", @"Cancel button title");		NSAlert *alert = [[NSAlert alloc] init];		[alert setMessageText:question];		[alert setInformativeText:info];		[alert addButtonWithTitle:quitButton];		[alert addButtonWithTitle:cancelButton];				NSInteger answer = [alert runModal];		[alert release];		alert = nil;				if (answer == NSAlertAlternateReturn) return NSTerminateCancel;			}		return NSTerminateNow;}/** Implementation of dealloc, to release the retained variables. */- (void) dealloc {		[window release];	[managedObjectContext release];	[persistentStoreCoordinator release];	[managedObjectModel release];		[taskContainer release];		[super dealloc];}@end